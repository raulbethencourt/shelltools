#!/bin/bash

initANSI() {
  # Foreground colors
  blackf=$(tput setaf 0)
  redf=$(tput setaf 1)
  greenf=$(tput setaf 2)
  yellowf=$(tput setaf 3)
  bluef=$(tput setaf 4)
  purplef=$(tput setaf 5)
  cyanf=$(tput setaf 6)
  whitef=$(tput setaf 7)

  # Background colors
  blackb=$(tput setab 0)
  redb=$(tput setab 1)
  greenb=$(tput setab 2)
  yellowb=$(tput setab 3)
  blueb=$(tput setab 4)
  purpleb=$(tput setab 5)
  cyanb=$(tput setab 6)
  whiteb=$(tput setab 7)

  # Bold, italic, underline and inverse style toggles
  boldon=$(tput smso)
  boldoff=$(tput rmso)
  italicon=$(tput sitm)
  italicoff=$(tput ritm)
  ulon=$(tput smul)
  uloff=$(tput rmul)
  inver=$(tput rev)

  reset=$(tput sgr0)
}
initANSI

in_path() {
  # Given a command and the PATH, tries to find the command. Returns 0 if
  #   found and executable; 1 if not. Note that this temporarily modifies
  #   the IFS (internal field separator) but restores it upon completion.
  cmd=$1
  ourpath=$2
  result=1
  oldIFS=$IFS
  IFS=":"

  for directory in $ourpath; do
    [ -x "$directory/$cmd" ] && result=0 # If we're here, we found the command.
  done

  IFS=$oldIFS
  return $result
}
checkForCmdInPath() {
  cmd=$1

  [ -n "$cmd" ] && {
    if [ "$(echo "$cmd" | cut -c1)" = "/" ]; then
      [ ! -x "$cmd" ] && return 1
    elif ! in_path "$cmd" "$PATH"; then
      return 2
    fi
  }
}
echon() {
  if checkForCmdInPath printf; then
    printf "%s" "$*"
  else
    echo "$*" | tr -d '\n'
  fi
}

getFileWithFzf() {
  file="$1"
  [ ! -f "$file" ] && [ ! -d "$file" ] && error_exit "$file is not a proper file or directory." 2

  FD=$(find "$file" -mindepth 1 -maxdepth 1 ! -name '.*')

  directory=$(
    echo "$FD" |
      sed -n '1p' |
      xargs -I {} dirname {}
  )
  file=$(
    echo "$FD" |
      xargs -I {} basename {} 2>/dev/null |
      fzf --bind=tab:up --bind=btab:down --bind=ctrl-g:first
  ) || exit 1
  [ -d "$directory/$file" ] && getFileWithFzf "$directory/$file/" || echo "$directory/$file"
}

getEnvFileFromPath() {
  envdir="$1"
  [ -z "$envdir" ] && error_exit "You must specify env directory."
  envfile=$(find "$envdir" -name ".env*")
  parentdir=$(dirname "$envdir")

  [ "$envdir" == "$HOME" ] && error_exit "You don't have any env file in your path."
  [ -z "$envfile" ] && getEnvFileFromPath "$parentdir" || echo "$envfile"
}
